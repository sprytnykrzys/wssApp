<?php

namespace AppBundle\Repository;

use Doctrine\ORM\EntityRepository;

/**
 * HierarchyRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class HierarchyRepository extends EntityRepository
{


    private $parentNodeIds = array();
    private $nodesById = array();

    const levels = [
        '0' => 'catalog',
        '1' => 'system_provider',
        '2' => 'system'
    ];

    const levelsPlural = [
        '0' => 'catalogs',
        '1' => 'system_providers',
        '2' => 'systems'
    ];

    public function findAllOrderedByName()
    {
        return $this->getEntityManager()
            ->createQuery(
                'SELECT c FROM AppBundle:Hierarchy c ORDER BY c.id ASC'
            )
            ->getResult();
    }
    public function findAllNested($hierarchyElements, $start = 0, &$unassigned = null)
    {
        $tree = array();
        foreach ($hierarchyElements as $node) {

            /* new algorithm */
            $this->parentNodeIds[$node['id']] = $node['id_parent'];
            $this->nodesById[$node['id']] = $node;
        }
        if($start == 0){
            $rootLevel = 0;
        }
        else{
            $rootLevel = $this->nodesById[$start]['level'];
        }
        $this->buildTreeRecursive($start, $tree);
        if(!is_null($unassigned)){
            foreach ($tree['subhierarchyElements'] as $key => $node){
                if($node['level'] != $rootLevel){
                    $unassigned[$key] = $node;
                    unset($tree['subhierarchyElements'][$key]);
                }
            }
        }
        return $tree['subhierarchyElements'];
    }
    /* helper methods */

    /**
     * @param integer $key
     * @param array $list
     *
     * @return array treeMap
     */
    private function digToRoot($key, &$list){
        $parent = isset($list[$key]) ? $list[$key] : 0;
        if($key){
            $arr = $this->digToRoot($parent, $list);
            $arr[] = $key;
            return $arr;
        }
        else{
            return [0];
        }
    }
    public function findAllTreeValid($hierarchyElements, $catId, $newParentId){
        $hierarchyElementsMap = array();
        $map = array();
        foreach ($hierarchyElements as $node) {
            $map[$node['id']] = $node['id_parent'];
            $hierarchyElementsMap[$node['id']] = $node;
        }
        $map[$catId] = $newParentId;
        $mapCopy = $map;
        foreach ($map as $id => $parent) {
            if(!$this->digRootValid($parent, $mapCopy)){
                return false;
            }
        }
        return true;
    }

    public function findAllByIdParent($id_parent = null)
    {
        if($id_parent == null){
            return array();
        }
        $em = $this->getEntityManager();
        $dql = "SELECT h FROM AppBundle:Hierarchy h WHERE h.id_parent = :idp";
        $result = $em->createQuery($dql)
            ->setParameters(array(
                'idp' => $id_parent,
            ))->getResult();
        if(is_array($result) && count($result)){
            return $result;
        }
        else{
            return array();
        }
    }
    private function digRootValid($key, $list, $visitedNodes = null){
        if(!$visitedNodes){
            $visitedNodes = array();
        }
        if(in_array($key, $visitedNodes)){ /* detect cycle */
            return false; /* cycle detected */
        }
        if(!array_key_exists($key, $list) && $key != 0){ /* consistency check */
            return false; /* tree detached */
        }
        $visitedNodes[] = $key;
        $parent = isset($list[$key]) ? $list[$key] : 0;
        if($key){
            return $this->digRootValid($parent, $list, $visitedNodes);
        }
        else{
            return true;
        }
    }
    private function buildTreeRecursive($currentId, &$currentNode){
        if($currentId != 0) {
            $currentNode = array_merge($currentNode, $this->nodesById[$currentId]);
        }
        if(in_array($currentId, $this->parentNodeIds)){
            $currentNode['subhierarchyElements'] = array();
        }
        foreach ($this->parentNodeIds as $catId=>$parentId){
            if($parentId != $currentId){
                continue;
            }
            unset($this->parentNodeIds[$catId]); /* optimisations */
            $currentNode['subhierarchyElements'][$catId] = array();
            $this->buildTreeRecursive($catId, $currentNode['subhierarchyElements'][$catId]);
        }
    }
    private function buildBranch($nodes, &$node, $level, $hierarchyElements, $self){
        $current = $nodes[$level];
        if(!is_array($node)){
            $node = array();
        }
        if(!array_key_exists($current, $node)){
            $node[$current] = isset($hierarchyElements[$current]) ? $hierarchyElements[$current] : array();
        }
        if(count($nodes) - 1 > $level){
            $this->buildBranch($nodes, $node[$current]['subhierarchyElements'], $level + 1, $hierarchyElements, $self);
        }
        else{
            if( isset($node[$current]['subhierarchyElements'][$self]) &&
                !empty($node[$current]['subhierarchyElements'][$self]) &&
                is_array($node[$current]['subhierarchyElements'][$self])
            ){
                $node[$current]['subhierarchyElements'][$self] = array_merge($hierarchyElements[$self], $node[$current]['subhierarchyElements'][$self]); /* prevent node override */
            }
            else{
                $node[$current]['subhierarchyElements'][$self] = $hierarchyElements[$self];
            }
        }
    }


}
